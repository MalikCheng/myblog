---
title: 分布式事务
date: 2019-08-03 21:25:18
tags: 分布式事务
---

### 一、分布式事务


![思维导图1.png](https://i.loli.net/2019/07/25/5d39c0c4610ca19045.png)


#### 1.分类：刚性事务与柔性事务

	刚性事务：满足ACID原则、强一致性（在任何时间、任何地点、任何接入方式（pc、phone..)、任何服务(多个微服务间)看到数据都是一致的)
	柔性事务：满足base理论、最终一致性。它和刚性事务不同，不要求在同一时刻数据一致，允许在一段时间内数据的不一致、但最终的数据要一致。

#### 2.刚性事务

##### 2.1 ACID原则

	SQL标准中定义了四种隔离级别，根据事务并发情况下，一个事务内对操作的数据不同的可见性(读到的数据域)区分，如未提交读、不可重复读、可重复读，然而串行化从根本上解决事务并发。一般来说隔离级别越低问题越多、并发读高。
	
	[四种隔离级别](https://www.cnblogs.com/jian-gao/p/10795407.html)

##### 2.2 刚性事务实现方法(金融行业对数据敏感)

    1. 传统本地事务实现ACID方式：
    	1.1 写前日志WAL(Write Ahead Logging)：写入磁盘先logging。数据完整性，可恢复数据减少丢失
    		有undo、redo操作。undo是记录事务修改前的值，都用在事务回滚到上个值；redo记录事务提交修改后的			值，多用在恢复还没写入data file(磁盘文件)但事务已经成功提交更新的数据。
         参考:理解数据库中的undo日志、redo日志、检查点https://www.cnblogs.com/l1pe1/p/8327849.html
         	https://segmentfault.com/a/1190000018058484
    	1.2 影子分页(Shadow paging)：以page覆盖方式恢复，实现简单、技术落后、现在很少使用
    
    2. 刚性事务实现
    	2.1 XA模型
    		三个角色：AP(应用程序)、RM(资源管理、如数据库)、TM(事务管理者、协调者)

[![详细.png](https://i.loli.net/2019/07/24/5d385d423d4c068120.png)](https://i.loli.net/2019/07/24/5d385d423d4c068120.png)

[![XA.png](https://i.loli.net/2019/07/24/5d385b1fd5c0675402.png)](https://i.loli.net/2019/07/24/5d385b1fd5c0675402.png)





3. 二段提交（2pc）-  分布式一致性协议

   	它是基于XA模型规范实现

      	过程如下

    - TM向所有RM发起prepare投票
     
    - RM同意，TM发起commit
     
    - RM commit过程若有宕机等异常，节点重启，根据XA recover对commit补偿
     
      例子如 组织爬山
     
      缺点：同步阻塞（一二段串行）、一二之间需锁定资源，数据库资源被锁定时间过程不适用与长事务（多个子操作构成长事务）			
     
      [![2pc.png](https://i.loli.net/2019/07/24/5d386123369d968443.png)](https://i.loli.net/2019/07/24/5d386123369d968443.png)


#### 3. 柔性事务

是对XA协议的妥协，它通过减低强一致性要求，从而降低数据库资源的锁定时间，提高可用性。

##### 3.1 理论知识

###### 3.1.1 CAP

Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）
对于共享数据系统，最多只能同时拥有CAP其中的两个，无法兼得。
真实系统应当是ACID与BASE的混合体

C、A、P三者关系，

					保持容错性P存在时，C A是互斥的，C提高A必定下降；P不存在时，CA可共存。
	
					保持可用性A下，一致性与容错性互斥(一致就没有错误，有错误就不一致）；
	
					保持一致性C下，可用性与容错性互斥(保持一致，机器要不允许可用要不就允许网络通信可以出现问题)

参考：[详解 CAP 定理 Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）](https://www.cnblogs.com/incognitor/p/9759956.html)

###### 3.1.2 BASE理论

BA：Basic Availability基本业务可用性（支持分区失败）
S：Soft state柔性状态（状态允许有短时间不同步，可异步）
E：Eventual consistency最终一致性（数据最终一致，可不是实时一致）
其中ACID，原子性与持久性必须根本保障；为了可用性、性能与降级服务的需要，只有降低一致性与隔离性的要求。
酸碱平衡（ACID-BASE Balance）

##### 3.2 实现方式

		通用实现方法：将一个长事务（分布式事务）拆分一个个短事务（本地事务），对齐提供补偿方法
	
		实现模型有:
	
				TCC模型：try-confirm-cancel、每个子业务都要实现try-confirm-cancel接口，对业务代码侵入大
	
									资源锁定交给业务方
![TCC.png](https://i.loli.net/2019/07/24/5d3873979d94d54135.png)
<img src="https://i.loli.net/2019/07/24/5d3873979d94d54135.png" alt="TCC.png" title="TCC.png" />


				Sagas模型：

![saga.png](https://i.loli.net/2019/07/24/5d38767561b2151386.png)

其中注意的是在子事务对应的补偿没有Cn，个人理解，因为分解成的子事务是本地事务，在最后一个子事务不需要补偿方法，自己rollback就可以，倒数第二个却不可以这样子它是依赖与最后事务，自己rollback是与最后事务隔离了，所以必须要保证有补偿方法。

业界大多是利用向后恢复，saga 的隔离要在业务层自己控制，对代码有侵入。




	具体实现：
	
		异步场景下，MQ消息驱动
	
		考虑问题 幂等性

参考：

https://segmentfault.com/a/1190000013396639

https://www.jianshu.com/p/d70df89665b9



 [深入理解幂等性](https://www.cnblogs.com/javalyy/p/8882144.html)

#### 区别


![对比.png](https://i.loli.net/2019/07/24/5d38787fc6d5c12247.png)


#### 2. 分布式事务解决多数据库数据不一致问题

数据不一致原因：多个DB之间、DB与缓存之间

具体解决是基于柔性事务的

方案有：	1. 异步场景下，MQ消息驱动

				根据解决本地事务中的不知是否成功提交消息到MQ的问题方案不同，具体有下实现：
方案一：业务方提供成功后回查

![方案一.png](https://i.loli.net/2019/07/25/5d39a96d4452498995.png)
![方案一详情.png](https://i.loli.net/2019/07/25/5d39a96d2bb6350085.png)
![方案一优缺点.png](https://i.loli.net/2019/07/25/5d39a96d227c483652.png)

方案二: 不嵌入代码，消息写入表中，本地事务消息表中
![方案二.png](https://i.loli.net/2019/07/25/5d39a96d125ba31391.png)


![方案二 优缺点.png](https://i.loli.net/2019/07/25/5d39aade8e76612728.png)

2. 同步场景下：用业务层驱动，基于Saga模型。视频中只是一二句带过没有细讲。

#### 3.解决缓存与数据库不一致方案

- 3.1 不一致原因

  - 根本原因是高并发下的环境造成,还要写与读可能会在不同的地方,这样不在一个库中难以用本地事务保证原子操作.如A写x的值，B读x的值，当A先与B但间隔非常小，按照逻辑B读到应是A修改的x值。但在高并发下，当A还没有将x置完，本地事务还没commit或本地commit后缓存中没来的及更新这样的情况，B读到是缓存中x以前的值，未提交读到内容，即脏数据了。归根到底是数据库操作和缓存操作是两个过程不是原子的，过程存在间隙，在间隙中来读请求会读到脏数据。
- 3.2思考:它两更新的先后次序能否解决不一致
- 不能，因这两步更新不是原子的，一方先失败可以终止返回，不让另一方更新了。但是一方先更新成功，后一方更新失败，两方对于一个记录产生了不一致。假设后一方是DB，那当缓存中该记录缓存项失效则会读到DB中旧值；若后一方是缓存，读请求直接读到了缓存中旧值！

- 3.3 解决方法

  - 有更新操作时，先删除缓存项（delete是防止读到脏数据），再更新DB。

    - 若先更新DB后delete cache item，delete失败会读到脏数据。先delete后更新，若delete失败直接返回false。

  - x秒后再删除缓存项。双重保障，保证缓存项失效，防止读到脏数据

  - 设置缓存项失效时间 Expired time

  - 缓存删除失败->  记录日志、脚本定期修正时间上保证最终一致

  - 写请求时，先delete 缓存项。 读时再填充缓存中去。

参考 ： 高并发下缓存和数据库一致性问题http://blog.sina.com.cn/s/blog_bd5db8370102xbj6.html
谈谈缓存跟数据库的数据一致性问题https://www.jianshu.com/p/a532962cb9e9